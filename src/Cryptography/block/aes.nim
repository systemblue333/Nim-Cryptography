import ../../../../Utility/src/Utility/dataformat/dataformat
import ../../../../Utility/src/Utility/codeutils/bits
import ../../../../Utility/src/Utility/codeutils/indexutils

const
  SubBytesTable: array[256, uint8] = [
  0x63'u8, 0x7c'u8, 0x77'u8, 0x7b'u8, 0xf2'u8, 0x6b'u8, 0x6f'u8, 0xc5'u8,
  0x30'u8, 0x01'u8, 0x67'u8, 0x2b'u8, 0xfe'u8, 0xd7'u8, 0xab'u8, 0x76'u8,
  0xca'u8, 0x82'u8, 0xc9'u8, 0x7d'u8, 0xfa'u8, 0x59'u8, 0x47'u8, 0xf0'u8,
  0xad'u8, 0xd4'u8, 0xa2'u8, 0xaf'u8, 0x9c'u8, 0xa4'u8, 0x72'u8, 0xc0'u8,
  0xb7'u8, 0xfd'u8, 0x93'u8, 0x26'u8, 0x36'u8, 0x3f'u8, 0xf7'u8, 0xcc'u8,
  0x34'u8, 0xa5'u8, 0xe5'u8, 0xf1'u8, 0x71'u8, 0xd8'u8, 0x31'u8, 0x15'u8,
  0x04'u8, 0xc7'u8, 0x23'u8, 0xc3'u8, 0x18'u8, 0x96'u8, 0x05'u8, 0x9a'u8,
  0x07'u8, 0x12'u8, 0x80'u8, 0xe2'u8, 0xeb'u8, 0x27'u8, 0xb2'u8, 0x75'u8,
  0x09'u8, 0x83'u8, 0x2c'u8, 0x1a'u8, 0x1b'u8, 0x6e'u8, 0x5a'u8, 0xa0'u8,
  0x52'u8, 0x3b'u8, 0xd6'u8, 0xb3'u8, 0x29'u8, 0xe3'u8, 0x2f'u8, 0x84'u8,
  0x53'u8, 0xd1'u8, 0x00'u8, 0xed'u8, 0x20'u8, 0xfc'u8, 0xb1'u8, 0x5b'u8,
  0x6a'u8, 0xcb'u8, 0xbe'u8, 0x39'u8, 0x4a'u8, 0x4c'u8, 0x58'u8, 0xcf'u8,
  0xd0'u8, 0xef'u8, 0xaa'u8, 0xfb'u8, 0x43'u8, 0x4d'u8, 0x33'u8, 0x85'u8,
  0x45'u8, 0xf9'u8, 0x02'u8, 0x7f'u8, 0x50'u8, 0x3c'u8, 0x9f'u8, 0xa8'u8,
  0x51'u8, 0xa3'u8, 0x40'u8, 0x8f'u8, 0x92'u8, 0x9d'u8, 0x38'u8, 0xf5'u8,
  0xbc'u8, 0xb6'u8, 0xda'u8, 0x21'u8, 0x10'u8, 0xff'u8, 0xf3'u8, 0xd2'u8,
  0xcd'u8, 0x0c'u8, 0x13'u8, 0xec'u8, 0x5f'u8, 0x97'u8, 0x44'u8, 0x17'u8,
  0xc4'u8, 0xa7'u8, 0x7e'u8, 0x3d'u8, 0x64'u8, 0x5d'u8, 0x19'u8, 0x73'u8,
  0x60'u8, 0x81'u8, 0x4f'u8, 0xdc'u8, 0x22'u8, 0x2a'u8, 0x90'u8, 0x88'u8,
  0x46'u8, 0xee'u8, 0xb8'u8, 0x14'u8, 0xde'u8, 0x5e'u8, 0x0b'u8, 0xdb'u8,
  0xe0'u8, 0x32'u8, 0x3a'u8, 0x0a'u8, 0x49'u8, 0x06'u8, 0x24'u8, 0x5c'u8,
  0xc2'u8, 0xd3'u8, 0xac'u8, 0x62'u8, 0x91'u8, 0x95'u8, 0xe4'u8, 0x79'u8,
  0xe7'u8, 0xc8'u8, 0x37'u8, 0x6d'u8, 0x8d'u8, 0xd5'u8, 0x4e'u8, 0xa9'u8,
  0x6c'u8, 0x56'u8, 0xf4'u8, 0xea'u8, 0x65'u8, 0x7a'u8, 0xae'u8, 0x08'u8,
  0xba'u8, 0x78'u8, 0x25'u8, 0x2e'u8, 0x1c'u8, 0xa6'u8, 0xb4'u8, 0xc6'u8,
  0xe8'u8, 0xdd'u8, 0x74'u8, 0x1f'u8, 0x4b'u8, 0xbd'u8, 0x8b'u8, 0x8a'u8,
  0x70'u8, 0x3e'u8, 0xb5'u8, 0x66'u8, 0x48'u8, 0x03'u8, 0xf6'u8, 0x0e'u8,
  0x61'u8, 0x35'u8, 0x57'u8, 0xb9'u8, 0x86'u8, 0xc1'u8, 0x1d'u8, 0x9e'u8,
  0xe1'u8, 0xf8'u8, 0x98'u8, 0x11'u8, 0x69'u8, 0xd9'u8, 0x8e'u8, 0x94'u8,
  0x9b'u8, 0x1e'u8, 0x87'u8, 0xe9'u8, 0xce'u8, 0x55'u8, 0x28'u8, 0xdf'u8,
  0x8c'u8, 0xa1'u8, 0x89'u8, 0x0d'u8, 0xbf'u8, 0xe6'u8, 0x42'u8, 0x68'u8,
  0x41'u8, 0x99'u8, 0x2d'u8, 0x0f'u8, 0xb0'u8, 0x54'u8, 0xbb'u8, 0x16'u8
  ]
  InvSubBytesTable: array[256, uint8] = [
  0x52'u8, 0x09'u8, 0x6a'u8, 0xd5'u8, 0x30'u8, 0x36'u8, 0xa5'u8, 0x38'u8,
  0xbf'u8, 0x40'u8, 0xa3'u8, 0x9e'u8, 0x81'u8, 0xf3'u8, 0xd7'u8, 0xfb'u8,
  0x7c'u8, 0xe3'u8, 0x39'u8, 0x82'u8, 0x9b'u8, 0x2f'u8, 0xff'u8, 0x87'u8,
  0x34'u8, 0x8e'u8, 0x43'u8, 0x44'u8, 0xc4'u8, 0xde'u8, 0xe9'u8, 0xcb'u8,
  0x54'u8, 0x7b'u8, 0x94'u8, 0x32'u8, 0xa6'u8, 0xc2'u8, 0x23'u8, 0x3d'u8,
  0xee'u8, 0x4c'u8, 0x95'u8, 0x0b'u8, 0x42'u8, 0xfa'u8, 0xc3'u8, 0x4e'u8,
  0x08'u8, 0x2e'u8, 0xa1'u8, 0x66'u8, 0x28'u8, 0xd9'u8, 0x24'u8, 0xb2'u8,
  0x76'u8, 0x5b'u8, 0xa2'u8, 0x49'u8, 0x6d'u8, 0x8b'u8, 0xd1'u8, 0x25'u8,
  0x72'u8, 0xf8'u8, 0xf6'u8, 0x64'u8, 0x86'u8, 0x68'u8, 0x98'u8, 0x16'u8,
  0xd4'u8, 0xa4'u8, 0x5c'u8, 0xcc'u8, 0x5d'u8, 0x65'u8, 0xb6'u8, 0x92'u8,
  0x6c'u8, 0x70'u8, 0x48'u8, 0x50'u8, 0xfd'u8, 0xed'u8, 0xb9'u8, 0xda'u8,
  0x5e'u8, 0x15'u8, 0x46'u8, 0x57'u8, 0xa7'u8, 0x8d'u8, 0x9d'u8, 0x84'u8,
  0x90'u8, 0xd8'u8, 0xab'u8, 0x00'u8, 0x8c'u8, 0xbc'u8, 0xd3'u8, 0x0a'u8,
  0xf7'u8, 0xe4'u8, 0x58'u8, 0x05'u8, 0xb8'u8, 0xb3'u8, 0x45'u8, 0x06'u8,
  0xd0'u8, 0x2c'u8, 0x1e'u8, 0x8f'u8, 0xca'u8, 0x3f'u8, 0x0f'u8, 0x02'u8,
  0xc1'u8, 0xaf'u8, 0xbd'u8, 0x03'u8, 0x01'u8, 0x13'u8, 0x8a'u8, 0x6b'u8,
  0x3a'u8, 0x91'u8, 0x11'u8, 0x41'u8, 0x4f'u8, 0x67'u8, 0xdc'u8, 0xea'u8,
  0x97'u8, 0xf2'u8, 0xcf'u8, 0xce'u8, 0xf0'u8, 0xb4'u8, 0xe6'u8, 0x73'u8,
  0x96'u8, 0xac'u8, 0x74'u8, 0x22'u8, 0xe7'u8, 0xad'u8, 0x35'u8, 0x85'u8,
  0xe2'u8, 0xf9'u8, 0x37'u8, 0xe8'u8, 0x1c'u8, 0x75'u8, 0xdf'u8, 0x6e'u8,
  0x47'u8, 0xf1'u8, 0x1a'u8, 0x71'u8, 0x1d'u8, 0x29'u8, 0xc5'u8, 0x89'u8,
  0x6f'u8, 0xb7'u8, 0x62'u8, 0x0e'u8, 0xaa'u8, 0x18'u8, 0xbe'u8, 0x1b'u8,
  0xfc'u8, 0x56'u8, 0x3e'u8, 0x4b'u8, 0xc6'u8, 0xd2'u8, 0x79'u8, 0x20'u8,
  0x9a'u8, 0xdb'u8, 0xc0'u8, 0xfe'u8, 0x78'u8, 0xcd'u8, 0x5a'u8, 0xf4'u8,
  0x1f'u8, 0xdd'u8, 0xa8'u8, 0x33'u8, 0x88'u8, 0x07'u8, 0xc7'u8, 0x31'u8,
  0xb1'u8, 0x12'u8, 0x10'u8, 0x59'u8, 0x27'u8, 0x80'u8, 0xec'u8, 0x5f'u8,
  0x60'u8, 0x51'u8, 0x7f'u8, 0xa9'u8, 0x19'u8, 0xb5'u8, 0x4a'u8, 0x0d'u8,
  0x2d'u8, 0xe5'u8, 0x7a'u8, 0x9f'u8, 0x93'u8, 0xc9'u8, 0x9c'u8, 0xef'u8,
  0xa0'u8, 0xe0'u8, 0x3b'u8, 0x4d'u8, 0xae'u8, 0x2a'u8, 0xf5'u8, 0xb0'u8,
  0xc8'u8, 0xeb'u8, 0xbb'u8, 0x3c'u8, 0x83'u8, 0x53'u8, 0x99'u8, 0x61'u8,
  0x17'u8, 0x2b'u8, 0x04'u8, 0x7e'u8, 0xba'u8, 0x77'u8, 0xd6'u8, 0x26'u8,
  0xe1'u8, 0x69'u8, 0x14'u8, 0x63'u8, 0x55'u8, 0x21'u8, 0x0c'u8, 0x7d'u8
  ]
  Rcon*: array[11, uint8] = [0x00'u8, 0x01'u8, 0x02'u8, 0x04'u8, 0x08'u8,
  0x10'u8, 0x20'u8, 0x40'u8, 0x80'u8, 0x1b'u8, 0x36'u8]

  AES128KeySize*: int = 16
  AES192KeySize*: int = 24
  AES256KeySize*: int = 32
  
  U32PerRound: int = 4
  U64PerRound: int = 2

  AESBlockSize*: int = 16
  
  AES128NumRounds*: int = 10
  AES192NumRounds*: int = 12
  AES256NumRounds*: int = 14

  AES128NumRoundsKeys*: int = AES128NumRounds + 1
  AES192NumRoundsKeys*: int = AES192NumRounds + 1
  AES256NumRoundsKeys*: int = AES256NumRounds + 1

  MaxNumRounds*: int = 14
  MaxkeyBytes*: int = 256 div 8
  
  Check64bit: bool = (sizeof(int) == 8) and (defined(amd64) or defined(alpha) or defined(powerpc64) or 
  defined(powerpc64el) or defined(sparc64) or defined(mips64el) or defined(ia64) or 
  defined(riscv64) or defined(loongarch64) or defined(mips64) or defined(s390x) or 
  defined(arm64) or defined(e2k))

  Check32bit: bool = (sizeof(int) == 4) and (defined(i386) or defined(m68k) or defined(powerpc) or
  defined(sparc) or defined(hppa) or defined(mips) or defined(mipsel) or defined(arm) or
  defined(riscv32))

type
  Aes128RoundKey* = array[44, uint32]
  Aes192RoundKey* = array[52, uint32]
  Aes256RoundKey* = array[60, uint32]
  AesRoundKey = concept x
    x is Aes128RoundKey or x is Aes192RoundKey or x is Aes256RoundKey

template addRoundKey(state: ptr array[2, uint64], key: ptr array[2, uint64]): void =
  for i in 0 ..< 2:
    state[i] = state[i] xor key[i]

template swap(x: var uint32): uint32 =
  (leftRotate(x, 8) and 0x00FF00FF'u32) or
  (rightRotate(x, 8) and 0xFF00FF00'u32)

template subByte(state: var array[16, uint8]): void =
  for i in 0 ..< 16:
    state[i] = SubBytesTable[state[i]]

template invSubByte(state: var array[16, uint8]): void =
  for i in 0 ..< 16:
    state[i] = InvSubBytesTable[state[i]]

template subWord(word: var uint32): void =
  var wordAddr: ptr array[4, uint8] = cast[ptr array[4, uint8]](addr word)
  
  for i in 0 ..< 4:
    wordAddr[i] = SubBytesTable[wordAddr[i]]

template rotWord(value: var uint32): void =
  bits.rightRotate(value, 0x8'u32)

template keyExpansionTemplate[T: AesRoundKey, N: static[int]](key: lent array[N, uint8], roundKey: var T): void =
  static:
    doAssert N == 16 or N == 24 or N == 32, "16, 24, 32 are only allowed for key length"

  lencopy(key, roundKey, key.len div 4)

  for i in (key.len div 4) ..< roundKey.len:
    var tmp: uint32
    if i mod 8 == 0:
      tmp = subWord(rotWord(roundKey[i - 1])) xor Rcon[i div 8]
    elif i mod 8 == 4:
      tmp = subWord(roundKey[i - 1])
    else:
      tmp = roundKey[i - 1]
    roundKey[i] = roundKey[i - 8] xor tmp

template shiftRows(state: var array[16, uint8]): void =
  var matrix: array[4, array[4, uint8]] = [
    [state[0], state[4], state[8], state[12]],
    [state[1], state[5], state[9], state[13]],
    [state[2], state[6], state[10], state[14]],
    [state[3], state[7], state[11], state[15]]
  ]

  for col in 0 ..< 4:
    state[col * 4 + 0] = matrix[0][col]
    state[col * 4 + 1] = matrix[1][(col + 1) mod 4]
    state[col * 4 + 2] = matrix[2][(col + 2) mod 4]  
    state[col * 4 + 3] = matrix[3][(col + 3) mod 4]

template invShiftRows(state: var array[16, uint8]): void =
  var matrix: array[4, array[4, uint8]] = [
    [state[0], state[4], state[8], state[12]],
    [state[1], state[5], state[9], state[13]],
    [state[2], state[6], state[10], state[14]],
    [state[3], state[7], state[11], state[15]]
  ]

  for col in 0 ..< 4:
    state[col * 4 + 0] = matrix[0][col]
    state[col * 4 + 1] = matrix[1][(col + 3) mod 4]
    state[col * 4 + 2] = matrix[2][(col + 2) mod 4]  
    state[col * 4 + 3] = matrix[3][(col + 1) mod 4]

template xtime(x: uint8): uint8 =
  ((x shl 1) xor (((x shr 7) and 1) * 0x1B'u8)) and 0xFF'u8

template gfMul(a, b: uint8): uint8 =
  case b
  of 0x01: a
  of 0x02: xtime(a)
  of 0x03: xtime(a) xor a
  of 0x09:
    let a2 = xtime(a)
    let a4 = xtime(a2)
    let a8 = xtime(a4)
    a8 xor a
  of 0x0B:
    let a2 = xtime(a)
    let a4 = xtime(a2)
    let a8 = xtime(a4)
    a8 xor a2 xor a
  of 0x0D:
    let a2 = xtime(a)
    let a4 = xtime(a2)
    let a8 = xtime(a4)
    a8 xor a4 xor a
  of 0x0E:
    let a2 = xtime(a)
    let a4 = xtime(a2)
    let a8 = xtime(a4)
    a8 xor a4 xor a2
  else:
    var res: uint8 = 0
    var aa = a
    var bb = b
    for i in 0 ..< 8:
      if (bb and 0x01'u8) != 0'u8:
        res = res xor aa
      let hiBit = (aa and 0x80'u8) != 0'u8
      aa = aa shl 1
      if hiBit:
        aa = aa xor 0x1B'u8
      bb = bb shr 1
    res

template mixColumns(state: var array[16, uint8]): void =
  for i in 0 ..< 4:
    var a: array[4, uint8] = [state[i * 4 + 0], state[i * 4 + 1], state[i * 4 + 2], state[i * 4 + 3]]

    state[i * 4 + 0] = (gfMul(a[0], 0x02'u8) xor gfMul(a[1], 0x03'u8) xor gfMul(a[2], 0x01'u8) xor gfMul(a[3], 0x01'u8))
    state[i * 4 + 1] = (gfMul(a[0], 0x01'u8) xor gfMul(a[1], 0x02'u8) xor gfMul(a[2], 0x03'u8) xor gfMul(a[3], 0x01'u8))
    state[i * 4 + 2] = (gfMul(a[0], 0x01'u8) xor gfMul(a[1], 0x01'u8) xor gfMul(a[2], 0x02'u8) xor gfMul(a[3], 0x03'u8))
    state[i * 4 + 3] = (gfMul(a[0], 0x03'u8) xor gfMul(a[1], 0x01'u8) xor gfMul(a[2], 0x01'u8) xor gfMul(a[3], 0x02'u8))

template invMixColumns(state: var array[16, uint8]): void =
  for i in 0 ..< 4:
    var a: array[4, uint8] = [state[i * 4 + 0], state[i * 4 + 1], state[i * 4 + 2], state[i * 4 + 3]]

    state[i * 4 + 0] = (gfMul(a[0], 0x0e'u8) xor gfMul(a[1], 0x0b'u8) xor gfMul(a[2], 0x0d'u8) xor gfMul(a[3], 0x09'u8))
    state[i * 4 + 1] = (gfMul(a[0], 0x09'u8) xor gfMul(a[1], 0x0e'u8) xor gfMul(a[2], 0x0b'u8) xor gfMul(a[3], 0x0d'u8))
    state[i * 4 + 2] = (gfMul(a[0], 0x0d'u8) xor gfMul(a[1], 0x09'u8) xor gfMul(a[2], 0x0e'u8) xor gfMul(a[3], 0x0b'u8))
    state[i * 4 + 3] = (gfMul(a[0], 0x0b'u8) xor gfMul(a[1], 0x0d'u8) xor gfMul(a[2], 0x09'u8) xor gfMul(a[3], 0x0e'u8))    
